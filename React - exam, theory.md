**React** - это JS-библиотека для отрисовки пользовательских интерфейсов (user interfaces, UI)

- Позволяет разбивать UI на отдельные части — компоненты.
- Оптимизирует работу с DOM-деревом.
- Позволяет обновлять только те части, что были изменены.

**React-компонент** — функция или класс для создания React-элемента. Компоненты должны называться с большой буквы. Компоненты должны вести себя как чистые функции по отношению к свойствам. (не менять)

**Чистая функция:**

- возвращает одинаковый результат при одинаковых входных параметрах
- не производит побочных эффектов (мутаций)

**React-элемент** — объект с описанием того, что React должен отрисовать в DOM-дереве.

**React-Фрагмент** <></> используется для обёртки нескольких элементов в один служебный, который не появится в DOM.

**Жизненные циклы:**

- **`Mount`** Монтирование - Первичная отрисовка компонента в реальный DOM. Перед отрисовкой каждый компонент превращается в дерево элементов.
- **`Update`** Обновление - Повторная отрисовка изменённого дерева элементов в DOM. Дерево элементов меняется при изменении props или состояния компонента.
- **`Unmount`** Размонтирование компонента — момент, когда полученное из компонента дерево элементов удаляется из реального DOM-дерева.

_`Virtual DOM` — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «реальным» DOM при помощи библиотеки, такой как ReactDOM. React сам превращает корневой компонент и все его дочерние узлы в
соответствующие в React-элементы. В результате получается дерево React-
элементов — Virtual DOM._

`Умный компонент` - компонент с состоянием отслеживает изменения в нём и отрисовывается (рендерится) заново. ( stateful / container / smart )

`Глупый компонент` без состояния — оболочка для статичного контента, данных или других компонентов. ( stateless / presentational / dumb )

**Хуки** — это функции, которые позволяют писать функциональные React-компоненты, которые имеют доступ к state, context, методам жизненного цикла, ref и т.д., без написания классов.

Правила хуков:

1. Можно вызывать только на верхнем уровне (НЕ используйте внутри циклов, условий, вложенных функций);
2. Можно вызывать только из React-функций (из функциональных компонентов или своих пользовательских хуков);
3. Название начинается с use…

---

# React Native Hooks

## useState()

это нативный хук состояния, позволяет писать “умные” компоненты с состоянием.
(для работы с состоянием компонента и работает только в функциональных компонентах)
React будет хранить это состояние между рендерами.

```ts
const [state, setState] = useState(initialState);
```

**Принимает** в себя аргумент изначального состояния (значение по умолчанию) (`initialState` - может быть любым типом данных, и даже функцией).

**Возвращает** массив с состоянием и функцией для обновления состояния (`кортеж` - массив с фиксированной длинной с установленными типами).

**`state`** - переменная состояния, при первом рендере равно **`initialState`**;

**`setState`** - функция для изменения состояния `state`, которая позволяет обновить состояние до другого значения и запустить повторный рендеринг. Может принимать в себя либо новое значение setValue(newState), либо callback-функцию с предыдущим значением в качестве параметра setValue((prevState) => {})

Данный хук используется для:

- управления состоянием, в том числе передачи данных как - пропсов другим компонентам
- условного рендеринга — рендер тех или иных данных, в зависимости от того, что хранится в стейте
- для переключения состояния (true/false)
- как счетчик чего-либо
- хранения данных полученных от сервера

```ts
const [state, setState] = useState(0);

setState((p) => p + 1); // 1
setState((p) => p + 1); // 2 - дожидается предыдущего состояния

setState(state + 1); // 1 - перезаписывает count
setState(state + 1); // 1
```

---

## useReducer()

это нативный хук состояния, для централизованной работы с состоянием приложения, архитектурно схож с библиотекой Redux.
ДЛЯ разделения логики отрисовки и работы с состоянием.
Используется для хранения всех данных приложения в одном месте и удобного их обновления.

_(В React по умолчанию нет какого-то глобального state (состояния), которое было бы доступно во всем приложении. Вы можете только сохранять данные в рамках одного компонента.)_

```ts
const [state, dispatch] = useReducer(reducer, initialState);
```

**Примает** в себя функцию reducer и начальное состояние.
**Возвращает** значение состояния(state) и функцию для обновления состояния(dispatch).

Если мы из reducer вернем тоже значение без изменения, то ререндеринг и запуск функций побочного эффекта не произойдет.

**`reducer`**— чистая функция, которая принимает предыдущее состояние и действие
(state и action), всегда возвращает новую версию состояния

**`initialState`** — функция, которая принимает в качестве параметра ‘initialArg’, формируя тем самым исходное состояние приложения. Если параметра ‘initialArg’ нет, воспринимается как переменная.

**`state`** — переменная которая хранит текущее состояние приложения, формируется на
основе исходного состояния. Обычно в виде объекта.

**`dispatch`** — функция взаимодействующая с reducer’ом, принимает в качестве
параметра объект с действием (action) и полезной нагрузкой.

```ts
const action = { type: 'some type'; payload: 'some value' };
```

Если состояние было обновлено, то компонент выполняет повторный рендеринг, и хук useReducer() возвращает новое значение состояния.

```ts
const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD': {
      const newTask = action.payload;
      const newState = [...state, { id: state.length + 1, text: newTask }];
      return newState;
    }
    case 'DELETE': {
      const newState = state.filter((el) => el.id !== action.payload);
      return newState;
    }
    case 'PUT': {
      console.log('PUT --', action.payload.id, action.payload.text); // проверка получения данных из формы изменения
      // const newText = action.payload;
      console.log(state);
      const newState = state.map((el) => {
        if (el.id === Number(action.payload.id)) {
          return action.payload;
        } else {
          return el;
        }
      });
      // console.log(newState);
      return newState;
    }
    default:
      return state;
  }
};
```

---

## useEfffect() ---

Нативный хук эффекта, позволяет выполнять побочные эффекты в компоненте (синхронизировать компонент с внещней системой).

(Хук для вызова функций побочного эффекта, т.к мы не можем их использовать в самом теле функционального компонента:
Мутации, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.)

Внешние эффекты:

- fetch
- таймеры
- addEventListener

```ts
useEffect(() => {}, []);
```

**Ничего не возвращает!**.
**Принимает** в себя два аргумента:

**`callback`**. Можно делать запросы на сервер, задание обработчиков событий на документ или что-то ещё; `Callback`-функция может возвращать другую функцию, которая будет выполнена сразу перед размонтированием (unmount) компонента

**`Массив зависимостей`**, состоящий из аргументов. При изменении значения внутри любого из них будет запускаться наш callback. Именно благодаря этому аргументу мы можем имитировать методы жизненного цикла.

Массив зависимостей:

- отсутствует - эффект срабатывает при каждом перерендере;
- [ ] - эффект срабатывает после первичного рендера React компонента. Если есть возврат функции очистки`return()=>{}`, то при размонтировании (нужно чистить таймеры/ обработчики событий/ иногда fetch)
- [ state ] - срабатывает после первичного рендера React компонента и далее при изменении переменной state.

1. Если мы укажем в качестве второго аргумента `пустой массив`, callback запустится на стадии монтирования компонента. А поскольку никаких зависимостей для хука внутри массива мы не задали, то аргумент callback не будет больше запускаться.

```ts
useEffect(() => {
  console.log('Монтирование произошло');
}, []);
```

2. Поскольку мы можем `указать в массиве только те зависимости`, которые нам нужны, useEffect запускается при изменении необходимых параметров. При этом важно учитывать, что useEffect запускается и на стадии монтирования.

```ts
useEffect(() => {
  console.log('Компонент был обновлен');
}, [state]);
```

3. `Возвращаем из useEffect callback`. Практически возвращаемый callback предшествует размонтированию.

```ts
useEffect(() => {
  return () => {
    console.log('Произойдет размонтирование');
  };
}, []);
```

Функция может вернуть функцию очистки. Функция очистки очищает предыдущий эффект перед выполнением следующего.

```ts
useEffect(() => {
  return () => {
    console.log('Произойдет очистка effect');
  };
}, [state]);
```

---

## useContext() ---

Хук позволяющий получать значения из компонента-провайдера на любом уровне
вложенности, передавать их от родительского компонента к дочернему, минуя промежуточные. (избавит от проблемы с props drilling.)
Компонент вызывающий useContext всегда будет перерендеривоться при изменении значения контекста.

1. Типизация состояния приложения `type State`
2. Типизация контекста `export type Context = {state: State}`
3. Создание контекста - в файле Context.ts метод `createContext`.

```ts
const initailContext: Context = { state: initState };
export const appContext = createContext(initailContext);
```

2. Передача данных. В app.tsx компоненты оборачиваем в компонент-провайдер `<Context.Provider value={{ value }}>`. Все вложенные в него компоненты смогут получить доступ к данным из параметра `value (зарезирвированное слово)`.

```ts
   return (
    <Context.Provider value={{ some_value }}>
      < Component A />
      < Component B />
    <Context.Provider>
  );
```

3. Получение контекста

```ts
const { value } = useContext(Context);
```

---

## useMemo() ---

Этот хук позволяет не производить одни и те же вычисления много раз.

Принимает в себя два аргумента:

callback

массив зависимостей, при изменении значения внутри любого из них будет запускаться наш callback.

Возвращает мемоизированное значение.

Допустим, у нас есть следующий компонент:

const MyComponent = ({a, b}) => {
const sqrt = a \* a;

return (

<div>
<div>А в квадрате: {sqrt}</div>
<div>B: {b}</div>
</div>
);
};

В этой ситуации компонент перерендеривается в том случае, если изменяется один из параметров – a или b. Представим, что у нас много раз изменяется параметр b, при этом параметр a остаётся прежним. В таком случае мы много раз вычисляем одно и то же произведение, которое помещаем в переменную sqrt. Но зачем нам это, если параметр a в этом случае остаётся прежним? Получается, мы лишний раз нагружаем наш ПК вычислениями одного и того же. И хотя в данном случае операция произведения не самая “энергозатратная”, в других ситуациях возможна лишняя нагрузка. Избежать избыточных вычислений нам помогает хук useMemo.

const MyComponent = ({a, b}) => {
const sqrt = useMemo(() => a \* a, [a]);

return (

<div>
<div>А в квадрате: {sqrt}</div>
<div>B: {b}</div>
</div>
);
};

По сути они работают также, как и в useEffect: как только меняется какая-то зависимость из массива, запускается callback, который рассчитывает другое значение. Если ни одна зависимость не поменялась, то при рендеринге в переменную будет подставлено предыдущее вычисленное значение.

---

# Хуки React Router DOM

## useParams() ---

Хук из библиотеки 'react-router-dom'.Используется для передачи параметров. Возвращает объект { key: value } параметров url из роута.

// App.js
<Route path="/users/:id" element={
<UserCard />
} />

const { id } = useParams();

--- можно получить доступ к нужным параметрам из url, с помощью которого можно отрендерить страницу
для конкретного запроса.

<-------------------------------------------------------------------------------------------->

## useNavigate() ---

хук из библиотеки 'react-router-dom'. Используется для перехода на определённую страницу.

Возвращает функцию, ничего не принимает

import { useNavigate } from 'react-router-dom';

const navigate = useNavigate();

navigate('/some path') или
navigate(-1);

Функция navigate, которая принимает в себя аргумент в виде пути по которому будет осуществлен переход или значение на которое будет осуществлен переход по истории навигации.

<-------------------------------------------------------------------------------------------->

---

# Хуки React Redux

## useSelector() --- хук из библиотеки 'react-redux'. Позволяет получить данные из хранилища Redux.

const value = useSelector((state) = state.'some key');

--- useSelector() принимает в себя функцию selector, которое вытаскивает определенные данные из хранилища Redux. Функция selector вызывается вне зависимости от рендера функционального компонента, за исключением если нужное значение не изменялось с предыдущего рендера, тогда selector вернет сохраненные данные без вызова самой функции. Также функция selector отслеживает изменения получаемых данных состояния и если мы обновляли состояние, то функции вызывается снова происходит ререндер компонента.

<-------------------------------------------------------------------------------------------->

## useDispatch() --- хук из библиотеки 'react-redux'. Позволяет использовать функцию dispatch из хранилища Redux.

const dispatch = useDispatch();
