*** React Native Hooks




## useState() --- 
хук для отслеживание состояния и его изменения;


const [state, setState] = useState(initialState);


Возвращает массив с состоянием и функцией для обновления состояния;


'state' - начальное состояние, которое при первом рендере равно initialState;
'setState' - функция для обновления состояния 'state';


const [state, setState] = useState(0);


 setState(p => p + 1 );  // 1 
 setState(p => p + 1 );  // 2 - дожидается предыдущего состояния


 setState(state + 1 );   // 1 - перезаписывает count 
 setState(state + 1 );   // 1 


<-------------------------------------------------------------------------------------------->1


## useEfffect() --- 


Хук эффекта, позволяет выполнять побочные эффекты в компоненте.
useEffect принимает в себя два аргумента:


callback. Можно делать запросы на сервер, задание обработчиков событий на документ или что-то ещё; Callback-функция может возвращать другую функцию, которая будет выполнена сразу перед размонтированием (unmount) компонента


массив, состоящий из аргументов. При изменении значения внутри любого из них будет запускаться наш callback. Именно благодаря этому аргументу мы можем имитировать методы жизненного цикла. 


Массив зависимостей: 


1. пустота - срабатывает при каждом перерендере
2. [ ] - Срабатывает после первичного рендера React компонента;
3. [ state ] - срабатывает после первичного рендера React компонента и далее при изменении state


Хук для вызова функций побочного эффекта, т.к мы не можем их использовать в самом теле функционального компонента: 


Мутации, таймеры, логирование и другие побочные эффекты не допускаются внутри основного тела функционального компонента (называемого этапом рендеринга React). Это приведёт к запутанным ошибкам и несоответствиям в пользовательском интерфейсе.


Этапы жизненного цикла функционального компонента:


1. Если мы укажем в качестве второго аргумента пустой массив, callback запустится на стадии монтирования компонента. А поскольку никаких зависимостей для хука внутри массива мы не задали, то аргумент callback не будет больше запускаться.


  useEffect(() => {
    console.log("Монтирование произошло");
  }, [ ]);




2. Поскольку мы можем указать в массиве только те зависимости, которые нам нужны, useEffect запускается при изменении необходимых параметров. При этом важно учитывать, что useEffect запускается и на стадии монтирования.


  useEffect(() => {
    console.log("Компонент был обновлен");
  }, [state]);




3. Возвращаем из useEffect callback. Практически возвращаемый callback предшествует размонтированию. 
 
useEffect(() => {
     return () => {
          console.log("Произойдет размонтирование");
     };
}, []);


Функция может вернуть функцию очистки. Функция очистки очищает предыдущий эффект перед выполнением следующего.


useEffect(() => {
     return () => {
          console.log("Произойдет очистка effect");
     };
}, [ state ]);


<-------------------------------------------------------------------------------------------->2














## useContext() --- 
Хук для передачи данных через дерево компонентов, контекст позволяет передавать данные от родительского компонента к дочернему, минуя промежуточные.


1. В файле Context.js мы создаём объект Context, вызывая метод createContext.


  import { createContext } from 'react';


  const Context = createContext();


  export default Context;




2. В app.js компоненты оборачиваем в компонент Context.Provider. Тем самым говорим, что все вложенные в него компоненты смогут получить доступ к данным, которые мы передаем, помещая их в параметр value.


   import Context from Context.js


   return (
    <Context.Provider value={{ value }}>
      < Component A > 
      < Component B >
    <Context.Provider>
  );




3. В Component A вытаскиваем value. Для этого мы должны использовать хук useContext, а в качестве аргумента у него будет объект Context. Хук useContext вернёт нам данные, переданные в параметр value у Context.Provider, которые мы поместим в переменную context.


  const { value }= useContext(Context);


Также он избавит от проблемы с props drilling.


Компонент вызывающий useContext всегда будет перерендеривоться при изменении значения контекста.


<-------------------------------------------------------------------------------------------->
















## useReducer() --- 




const [state, dispatch] = useReducer(reducer, initialState);


--- useReducer примате в себя функцию reducer и начальное состояние. Возвращает значение состояния(state) и функцию для обновления состояния(dispatch). Если мы из reducer вернем тоже значение без изменения, то ререндеринг и запуск функций побочного эффекта не произойдет.


reducer — чистая функция, которая принимает предыдущее состояние и действие
(state и action), всегда возвращает новую версию состояния


initialState — функция, которая принимает в качестве параметра ‘initialArg’, формируя тем самым исходное состояние приложения. Если параметра ‘initialArg’ нет, воспринимается как переменная.


state — переменная которая хранит текущее состояние приложения, формируется на
основе исходного состояния. Обычно в виде объекта.


dispatch — функция взаимодействующая с reducer’ом, принимает в качестве
параметра объект с действием (action) и полезной нагрузкой. Только dispatch может
менять state.


const action = { type: 'some type'; payload: 'some value' };


Если состояние было обновлено, то компонент выполняет повторный рендеринг, и хук useReducer() возвращает новое значение состояния.


const reducer = (state, action) => {
  switch (action.type) {
    case 'ADD': {
      const newTask = action.payload;
      const newState = [...state, { id: state.length + 1, text: newTask }];
      return newState;
    }
    case 'DELETE': {
      const newState = state.filter((el) => el.id !== action.payload)
      return newState;
    }
    case 'PUT': {
      console.log('PUT --', action.payload.id, action.payload.text); // проверка получения данных из формы изменения
      // const newText = action.payload;
      console.log(state);
      const newState = state.map((el) => {
        if(el.id === Number(action.payload.id)) {
          return action.payload;
        } else {
          return el;
        }
  });
  // console.log(newState);
  return newState;
}
    default:
return state;
  }
}


<-------------------------------------------------------------------------------------------->




## useMemo() --- 
Этот хук позволяет не производить одни и те же вычисления много раз. 


Принимает в себя два аргумента:


callback 


массив зависимостей, при изменении значения внутри любого из них будет запускаться наш callback. 


Возвращает мемоизированное значение.


Допустим, у нас есть следующий компонент:


const MyComponent = ({a, b}) => {
  const sqrt = a * a;
 
  return (
    <div>
      <div>А в квадрате: {sqrt}</div>
      <div>B: {b}</div>
    </div>
  );
};


В этой ситуации компонент перерендеривается в том случае, если изменяется один из параметров – a или b. Представим, что у нас много раз изменяется параметр b, при этом параметр a остаётся прежним. В таком случае мы много раз вычисляем одно и то же произведение, которое помещаем в переменную sqrt. Но зачем нам это, если параметр a в этом случае остаётся прежним? Получается, мы лишний раз нагружаем наш ПК вычислениями одного и того же. И хотя в данном случае операция произведения не самая “энергозатратная”, в других ситуациях возможна лишняя нагрузка. Избежать избыточных вычислений нам помогает хук useMemo.


const MyComponent = ({a, b}) => {
  const sqrt = useMemo(() => a * a, [a]);
 
  return (
    <div>
      <div>А в квадрате: {sqrt}</div>
      <div>B: {b}</div>
    </div>
  );
};


По сути они работают также, как и в useEffect: как только меняется какая-то зависимость из массива, запускается callback, который рассчитывает другое значение. Если ни одна зависимость не поменялась, то при рендеринге в переменную будет подставлено предыдущее вычисленное значение.


<-------------------------------------------------------------------------------------------->


<-------------------------------------------------------------------------------------------->








*** Hooks


## useParams() --- 
Хук из библиотеки 'react-router-dom'.Используется для передачи параметров. Возвращает объект { key: value } параметров url из роута.


// App.js
<Route path="/users/:id" element={
<UserCard />
} />


const { id }  = useParams();


--- можно получить доступ к нужным параметрам из url, с помощью которого можно отрендерить страницу 
для конкретного запроса.




<-------------------------------------------------------------------------------------------->






## useNavigate() --- 
хук из библиотеки 'react-router-dom'. Используется для перехода на определённую страницу. 


Возвращает функцию, ничего не принимает


import { useNavigate } from 'react-router-dom';


const navigate = useNavigate();


navigate('/some path') или 
navigate(-1);


Функция navigate, которая принимает в себя аргумент в виде пути по которому будет осуществлен переход или значение на которое будет осуществлен переход по истории навигации.




<-------------------------------------------------------------------------------------------->




## useSelector() --- хук из библиотеки 'react-redux'. Позволяет получить данные из хранилища Redux.


const value = useSelector((state) = state.'some key');


--- useSelector() принимает в себя функцию selector, которое вытаскивает определенные данные из хранилища Redux. Функция selector вызывается вне зависимости от рендера функционального компонента, за исключением если нужное значение не изменялось с предыдущего рендера, тогда selector вернет сохраненные данные без вызова самой функции. Также функция selector отслеживает изменения получаемых данных состояния и если мы обновляли состояние, то функции вызывается снова происходит ререндер компонента.




<-------------------------------------------------------------------------------------------->




## useDispatch() --- хук из библиотеки 'react-redux'. Позволяет использовать функцию dispatch из хранилища Redux. 


const dispatch = useDispatch();